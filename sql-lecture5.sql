-- 부조회(서브쿼리) 먼저 실행이 되야하는 경우 사용
-- 구절의 순서를 바꿔야 하는 경우
SELECT * 
FROM NOTICE
WHERE ROWNUM BETWEEN 1 AND 5;
-- 최신 등록순으로 정렬한 결과에서 가장 최신글 5개를 원하는 경우라면?
SELECT *
FROM ( SELECT * FROM NOTICE ORDER BY REGDATE DESC )
WHERE ROWNUM BETWEEN 1 AND 5;

-- 나이가 30 이상인 회원 목록을 조회하시오.
SELECT *
FROM MEMBER
WHERE AGE >= 30; 

-- 평균나이 이상인 회원 구하기
SELECT *
FROM MEMBER
WHERE AGE >= (SELECT AVG(AGE) FROM MEMBER);

/*
 	조인(JOIN) : '두 개 이상의 테이블을 서로 연결하여 데이터를 검색할 때 
				사용하는 방법으로?두 개의 테이블을 마치 하나의 테이블인 것처럼 보여주는 것이다.?'?
 	조인의 종류 :
 	INNER JOIN, OUTER JOIN, SELF JOIN, CROSS JOIN(Cartesian Product)
 	
 	서로 관계가 있는 레코드들은 INNER
 	관계가 없는 레코드들은 OUTER
 **/

-- INNER JOIN : 관계가 있는 레코드들만 합치는 조인
-- 참조키를 기준으로 일치하는 행만 조인
-- MEMBER INNER JOIN NOTICE ON MEMBER.ID = NOTICE.WRITER_ID 
-- 표준방식
SELECT * 
FROM MEMBER INNER JOIN NOTICE 
	ON MEMBER.ID = NOTICE.WRITER_ID; 

SELECT *
FROM MEMBER A, NOTICE B
WHERE A.ID = B.WRITER_ID ;


-- OUTER JOIN
-- 참조키를 기준으로 일치하지 않는 행도 포함시키는 조인
-- MEMBER LEFT/RIGHT/FULL OUTER JOIN NOTICE ON MEMBER.ID = NOTICE.WRITER_ID 
SELECT *
FROM MEMBER A LEFT OUTER JOIN NOTICE B 
	ON A.ID = B.WRITER_ID ;

SELECT *
FROM MEMBER A RIGHT OUTER JOIN NOTICE B 
	ON A.ID = B.WRITER_ID ;

SELECT *
FROM MEMBER A FULL OUTER JOIN NOTICE B 
	ON A.ID = B.WRITER_ID ;


-- 내부 조인 연습
-- 컬럼을 지정하는 식별자를 줄이기 위해서 테이블의 별칭을 사용
SELECT B.ID , B.WRITER_ID , A.NAME 
FROM MEMBER A INNER JOIN NOTICE B 
	ON A.ID = B.WRITER_ID ;

-- ID, NAME 그리고 회원별 작성한 게시글 수를 조회하시오.
SELECT A.ID , A.NAME , COUNT(B.ID) COUNT 
FROM MEMBER A LEFT OUTER JOIN NOTICE B
	ON A.ID = B.WRITER_ID
GROUP BY A.ID , A.NAME ;


-- 자기 조인(SELF JOIN)
-- 데이터가 서로 포함 관계를 가지는 경우 : 담당, 구성, 연락
SELECT M.*, B.NAME BOSS_NAME
FROM MEMBER M LEFT OUTER JOIN MEMBER B
	ON B.ID = M.BOSS_ID;



/*
 	오라클 INNER JOIN  
 	
 	- ANSI INNER JOIN
 	SELECT B.ID, B.TLTLE, A.NAME
	FROM MEMBER A INNER JOIN NOTICE B
		ON A.ID = B.WRITER_ID; 
		
	- ORACLE INNER JOIN
	SELECT B.ID, B.TLTLE, A.NAME 
	FROM MEMBER A, NOTICE B
	WHERE A.ID = B.WRITER_ID; 
	
	- ANSI OUTER JOIN
	SELECT B.ID, B.TLTLE, A.NAME
	FROM MEMBER A LEFT OUTER JOIN NOTICE B
		ON A.ID = B.WRITER_ID;
		
	- ORACLE OUTER JOIN
	SELECT B.ID, B.TLTLE, A.NAME
	FROM MEMBER A, NOTICE B
	WHERE A.ID = B.WRITER_ID(+) ;
	
	- ORACLE FULL OUTER JOIN은 지원하지 않는다.
 */
SELECT N.*, M.NAME WRITER_NAME
FROM NOTICE N JOIN MEMBER M 
	ON M.ID = N.WRITER_ID ;


SELECT N.*, M.NAME WRITER_NAME
FROM NOTICE N, MEMBER M 
WHERE M.ID = N.WRITER_ID ;


SELECT N.*, M.NAME WRITER_NAME
FROM NOTICE N, MEMBER M 
WHERE M.ID(+) = N.WRITER_ID ;



-- 유니온(UNION) : 두 개의 SELECT 결과를 합침
-- UNION, MINUS, INTERSECT, UNION ALL
SELECT ID, NAME FROM MEMBER
	UNION -- 공통된 것은 제외함
SELECT WRITER_ID, TITLE FROM NOTICE;

SELECT ID, NAME FROM MEMBER
	UNION ALL -- 전체가 다 나옴
SELECT WRITER_ID, TITLE FROM NOTICE;

SELECT ID, NAME FROM MEMBER
	MINUS -- 위에 가지고 있는 것중 밑에랑 공통된 것을 빼줌
SELECT WRITER_ID, TITLE FROM NOTICE;

SELECT ID, NAME FROM MEMBER
	INTERSECT -- 공통된 것만 남겨둠
SELECT WRITER_ID, TITLE FROM NOTICE;


SELECT ID, NAME 
FROM MEMBER 
WHERE ID LIKE '%k%' 
	MINUS
SELECT ID, NAME 
FROM MEMBER 
WHERE ID LIKE '%n%';


SELECT ID, NAME 
FROM MEMBER 
WHERE ID LIKE '%k%' 
	UNION
SELECT ID, NAME 
FROM MEMBER 
WHERE ID LIKE '%n%';


-- VIEW(뷰) 만들기
-- 게시글 조인하기
CREATE VIEW NOTICE_VIEW
AS
	SELECT N.ID , N.TITLE , N.WRITER_ID , M.NAME , COUNT(C.ID) CNT 
	FROM MEMBER M 
	RIGHT OUTER JOIN NOTICE N ON M.ID = N.WRITER_ID 
	LEFT OUTER JOIN "COMMENT" C ON N.ID = C.NOTICE_ID 
	GROUP BY N.ID , N.TITLE , N.WRITER_ID , M.NAME ;

SELECT * FROM NOTICE_VIEW;

SELECT * FROM USER_TABLES;
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME='NOTICE';
































